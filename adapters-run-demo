# PDF Adapters & Advanced Components

## PDF Engine Adapters

### frontend/src/lib/pdf/pdfjs.adapter.ts

\`\`\`typescript
import * as pdfjsLib from 'pdfjs-dist';
import type { PDFDocument, Rect } from '@/lib/types';

export interface IPdfJsAdapter {
  renderPage(pdfBytes: ArrayBuffer, pageNum: number, scale: number): Promise<HTMLCanvasElement>;
  getMetadata(pdfBytes: ArrayBuffer): Promise<PDFMetadata>;
  getPageCount(pdfBytes: ArrayBuffer): Promise<number>;
  getPageDimensions(pdfBytes: ArrayBuffer, pageNum: number): Promise<{ width: number; height: number }>;
}

export interface PDFMetadata {
  title?: string;
  author?: string;
  subject?: string;
  creator?: string;
  producer?: string;
  creationDate?: Date;
  modificationDate?: Date;
  encrypted: boolean;
}

class PdfJsAdapter implements IPdfJsAdapter {
  constructor() {
    if (typeof window !== 'undefined') {
      (pdfjsLib as any).GlobalWorkerOptions.workerSrc = '/pdf.worker.js';
    }
  }

  async renderPage(
    pdfBytes: ArrayBuffer,
    pageNum: number,
    scale: number = 1.5
  ): Promise<HTMLCanvasElement> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({ scale });

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = viewport.width;
    canvas.height = viewport.height;

    await page.render({
      canvasContext: context,
      viewport: viewport,
    }).promise;

    return canvas;
  }

  async getMetadata(pdfBytes: ArrayBuffer): Promise<PDFMetadata> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const meta = await pdf.getMetadata();

    return {
      title: meta.info?.Title,
      author: meta.info?.Author,
      subject: meta.info?.Subject,
      creator: meta.info?.Creator,
      producer: meta.info?.Producer,
      encrypted: pdf.isEncrypted,
    };
  }

  async getPageCount(pdfBytes: ArrayBuffer): Promise<number> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    return pdf.numPages;
  }

  async getPageDimensions(
    pdfBytes: ArrayBuffer,
    pageNum: number
  ): Promise<{ width: number; height: number }> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({ scale: 1 });

    return {
      width: viewport.width,
      height: viewport.height,
    };
  }
}

export const pdfJsAdapter = new PdfJsAdapter();
\`\`\`

### frontend/src/lib/pdf/pdf-lib.adapter.ts

\`\`\`typescript
import { PDFDocument as PdfLibDocument, PDFPage, rgb, degrees } from 'pdf-lib';
import type { PDFDocument as AppDocument, Annotation, Rect } from '@/lib/types';

export interface IPdfLibAdapter {
  createDocument(): Promise<PdfLibDocument>;
  loadDocument(pdfBytes: ArrayBuffer): Promise<PdfLibDocument>;
  addPage(doc: PdfLibDocument, width?: number, height?: number): PDFPage;
  addText(
    page: PDFPage,
    text: string,
    bounds: Rect,
    options?: TextOptions
  ): void;
  addImage(
    page: PDFPage,
    imageBytes: ArrayBuffer,
    bounds: Rect,
    options?: ImageOptions
  ): Promise<void>;
  addRectangle(
    page: PDFPage,
    bounds: Rect,
    options?: ShapeOptions
  ): void;
  addHighlight(
    page: PDFPage,
    bounds: Rect,
    color?: string
  ): void;
  extractPages(
    doc: PdfLibDocument,
    pageIndices: number[]
  ): Promise<PdfLibDocument>;
  mergePdfs(
    docs: ArrayBuffer[]
  ): Promise<PdfLibDocument>;
  saveDocument(doc: PdfLibDocument): Promise<ArrayBuffer>;
  encryptDocument(
    doc: PdfLibDocument,
    password: string
  ): Promise<ArrayBuffer>;
  rotatePage(
    doc: PdfLibDocument,
    pageNum: number,
    degrees: number
  ): void;
}

export interface TextOptions {
  fontSize?: number;
  color?: { r: number; g: number; b: number };
  fontName?: string;
  bold?: boolean;
  italic?: boolean;
}

export interface ImageOptions {
  width?: number;
  height?: number;
  opacity?: number;
}

export interface ShapeOptions {
  fillColor?: { r: number; g: number; b: number };
  strokeColor?: { r: number; g: number; b: number };
  strokeWidth?: number;
  opacity?: number;
}

class PdfLibAdapter implements IPdfLibAdapter {
  async createDocument(): Promise<PdfLibDocument> {
    return PdfLibDocument.create();
  }

  async loadDocument(pdfBytes: ArrayBuffer): Promise<PdfLibDocument> {
    return PdfLibDocument.load(pdfBytes);
  }

  addPage(doc: PdfLibDocument, width = 612, height = 792): PDFPage {
    return doc.addPage([width, height]);
  }

  addText(
    page: PDFPage,
    text: string,
    bounds: Rect,
    options: TextOptions = {}
  ): void {
    const {
      fontSize = 12,
      color = rgb(0, 0, 0),
    } = options;

    page.drawText(text, {
      x: bounds.x,
      y: bounds.y,
      size: fontSize,
      color,
    });
  }

  async addImage(
    page: PDFPage,
    imageBytes: ArrayBuffer,
    bounds: Rect,
    options: ImageOptions = {}
  ): Promise<void> {
    const image = await (page.doc as any).embedPng(imageBytes);
    const { width = bounds.width, height = bounds.height } = options;

    page.drawImage(image, {
      x: bounds.x,
      y: bounds.y,
      width,
      height,
    });
  }

  addRectangle(
    page: PDFPage,
    bounds: Rect,
    options: ShapeOptions = {}
  ): void {
    const {
      fillColor = rgb(1, 1, 1),
      strokeColor = rgb(0, 0, 0),
      strokeWidth = 1,
    } = options;

    page.drawRectangle({
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height,
      borderColor: strokeColor,
      borderWidth: strokeWidth,
      color: fillColor,
    });
  }

  addHighlight(
    page: PDFPage,
    bounds: Rect,
    color = 'yellow'
  ): void {
    const colorMap: Record<string, any> = {
      yellow: rgb(1, 1, 0),
      green: rgb(0, 1, 0),
      red: rgb(1, 0, 0),
      blue: rgb(0, 0, 1),
    };

    page.drawRectangle({
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height,
      color: colorMap[color] || rgb(1, 1, 0),
      opacity: 0.3,
    });
  }

  async extractPages(
    doc: PdfLibDocument,
    pageIndices: number[]
  ): Promise<PdfLibDocument> {
    const newDoc = await PdfLibDocument.create();
    const pages = doc.getPages();

    for (const idx of pageIndices) {
      if (idx >= 0 && idx < pages.length) {
        const [copiedPage] = await newDoc.copyPages(doc, [idx]);
        newDoc.addPage(copiedPage);
      }
    }

    return newDoc;
  }

  async mergePdfs(docs: ArrayBuffer[]): Promise<PdfLibDocument> {
    const mergedDoc = await PdfLibDocument.create();

    for (const docBytes of docs) {
      const pdf = await PdfLibDocument.load(docBytes);
      const pages = pdf.getPages();
      const [copiedPages] = await mergedDoc.copyPages(pdf, pages.map((_, i) => i));
      mergedDoc.addPage(copiedPages);
    }

    return mergedDoc;
  }

  async saveDocument(doc: PdfLibDocument): Promise<ArrayBuffer> {
    return doc.save();
  }

  async encryptDocument(
    doc: PdfLibDocument,
    password: string
  ): Promise<ArrayBuffer> {
    doc.encrypt({ userPassword: password, ownerPassword: password });
    return doc.save();
  }

  rotatePage(
    doc: PdfLibDocument,
    pageNum: number,
    angle: number
  ): void {
    const pages = doc.getPages();
    if (pageNum >= 0 && pageNum < pages.length) {
      pages[pageNum].setRotation(degrees(angle));
    }
  }
}

export const pdfLibAdapter = new PdfLibAdapter();
\`\`\`

### frontend/src/lib/ocr/tesseract.provider.ts

\`\`\`typescript
import Tesseract from 'tesseract.js';
import type { OcrResult } from '@/lib/types';

export interface IOcrProvider {
  processImage(imageData: ImageData): Promise<OcrResult>;
  processPage(canvas: HTMLCanvasElement): Promise<OcrResult>;
  processBatch(
    canvases: HTMLCanvasElement[],
    onProgress?: (progress: number) => void
  ): Promise<OcrResult[]>;
}

class TesseractOcrProvider implements IOcrProvider {
  private worker: any = null;

  async getWorker() {
    if (!this.worker) {
      this.worker = await Tesseract.createWorker();
    }
    return this.worker;
  }

  async processImage(imageData: ImageData): Promise<OcrResult> {
    const worker = await this.getWorker();
    const result = await worker.recognize(imageData);

    return {
      text: result.data.text,
      confidence: result.data.confidence || 0.8,
    };
  }

  async processPage(canvas: HTMLCanvasElement): Promise<OcrResult> {
    const imageData = canvas
      .getContext('2d')!
      .getImageData(0, 0, canvas.width, canvas.height);
    return this.processImage(imageData);
  }

  async processBatch(
    canvases: HTMLCanvasElement[],
    onProgress?: (progress: number) => void
  ): Promise<OcrResult[]> {
    const results: OcrResult[] = [];

    for (let i = 0; i < canvases.length; i++) {
      const result = await this.processPage(canvases[i]);
      results.push(result);

      if (onProgress) {
        onProgress(((i + 1) / canvases.length) * 100);
      }
    }

    return results;
  }

  async terminate() {
    if (this.worker) {
      await this.worker.terminate();
      this.worker = null;
    }
  }
}

export const tesseractOcrProvider = new TesseractOcrProvider();
\`\`\`

### frontend/src/lib/adapters/export/wordAdapter.ts

\`\`\`typescript
import type { PDFDocument } from '@/lib/types';

export interface IWordExporter {
  export(pdfDoc: PDFDocument): Promise<ArrayBuffer>;
}

class FreeWordExporter implements IWordExporter {
  async export(pdfDoc: PDFDocument): Promise<ArrayBuffer> {
    // Stub: In production, integrate with a service like Cloud Convert or Libreoffice
    // For now, return a simple placeholder
    
    const xmlContent = \`<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <body>
    <p>
      <t>Converted from: \${pdfDoc.name}</t>
    </p>
    <p>
      <t>Pages: \${pdfDoc.numPages}</t>
    </p>
  </body>
</document>\`;

    return new TextEncoder().encode(xmlContent).buffer;
  }
}

export const wordExporter = new FreeWordExporter();
\`\`\`

### frontend/src/lib/adapters/export/imageAdapter.ts

\`\`\`typescript
import * as pdfjsLib from 'pdfjs-dist';
import type { PDFDocument } from '@/lib/types';

export interface IImageExporter {
  exportAsImage(
    pdfBytes: ArrayBuffer,
    pageNum: number,
    format: 'png' | 'jpg',
    scale: number
  ): Promise<Blob>;
  exportAllPages(
    pdfBytes: ArrayBuffer,
    format: 'png' | 'jpg',
    scale: number
  ): Promise<Blob[]>;
}

class ImageExporter implements IImageExporter {
  async exportAsImage(
    pdfBytes: ArrayBuffer,
    pageNum: number,
    format: 'png' | 'jpg' = 'png',
    scale: number = 2
  ): Promise<Blob> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({ scale });

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = viewport.width;
    canvas.height = viewport.height;

    await page.render({
      canvasContext: context,
      viewport: viewport,
    }).promise;

    return new Promise((resolve) => {
      canvas.toBlob(
        (blob) => resolve(blob!),
        format === 'png' ? 'image/png' : 'image/jpeg',
        format === 'jpg' ? 0.95 : undefined
      );
    });
  }

  async exportAllPages(
    pdfBytes: ArrayBuffer,
    format: 'png' | 'jpg' = 'png',
    scale: number = 2
  ): Promise<Blob[]> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const blobs: Blob[] = [];

    for (let i = 1; i <= Math.min(pdf.numPages, 50); i++) {
      const blob = await this.exportAsImage(pdfBytes, i, format, scale);
      blobs.push(blob);
    }

    return blobs;
  }
}

export const imageExporter = new ImageExporter();
\`\`\`

### frontend/src/lib/adapters/export/htmlAdapter.ts

\`\`\`typescript
import * as pdfjsLib from 'pdfjs-dist';

export interface IHtmlExporter {
  export(pdfBytes: ArrayBuffer): Promise<string>;
}

class HtmlExporter implements IHtmlExporter {
  async export(pdfBytes: ArrayBuffer): Promise<string> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body { font-family: Arial; margin: 20px; } .page { page-break-after: always; border: 1px solid #ccc; margin-bottom: 20px; padding: 20px; }</style></head><body>';

    for (let i = 1; i <= Math.min(pdf.numPages, 100); i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      html += '<div class="page"><h2>Page ' + i + '</h2>';

      for (const item of textContent.items as any[]) {
        html += '<p>' + (item.str || '') + '</p>';
      }

      html += '</div>';
    }

    html += '</body></html>';
    return html;
  }
}

export const htmlExporter = new HtmlExporter();
\`\`\`

### frontend/src/lib/adapters/export/textAdapter.ts

\`\`\`typescript
import * as pdfjsLib from 'pdfjs-dist';

export interface ITextExporter {
  export(pdfBytes: ArrayBuffer): Promise<string>;
}

class TextExporter implements ITextExporter {
  async export(pdfBytes: ArrayBuffer): Promise<string> {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    let text = '';

    for (let i = 1; i <= Math.min(pdf.numPages, 100); i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();

      text += `\n--- Page ${i} ---\n`;

      for (const item of textContent.items as any[]) {
        text += item.str || '';
      }
    }

    return text;
  }
}

export const textExporter = new TextExporter();
\`\`\`

---

## Complete Install & Run Commands

### 1. Initial Setup

\`\`\`bash
# Clone repository
git clone https://github.com/your-org/pdf-editor-pro.git
cd pdf-editor-pro

# Install dependencies across all workspaces
pnpm install -w

# Verify installation
pnpm ls -r --depth=0
\`\`\`

### 2. Environment Configuration

**frontend/.env.local:**
\`\`\`
NEXT_PUBLIC_PDF_WORKER_SRC=/pdf.worker.js
NEXT_PUBLIC_API_BASE=http://localhost:3001
APRYSE_ENABLED=false
\`\`\`

**backend/.env:**
\`\`\`
PORT=3001
CORS_ORIGIN=http://localhost:3000
NODE_ENV=development
\`\`\`

### 3. Development

\`\`\`bash
# Start both frontend and backend concurrently
pnpm dev

# Or start individually in separate terminals:
# Terminal 1:
pnpm -C frontend dev

# Terminal 2:
pnpm -C backend dev
\`\`\`

### 4. Production Build

\`\`\`bash
# Build both applications
pnpm build

# Start production servers
pnpm -C frontend start &
pnpm -C backend start
\`\`\`

### 5. Docker

\`\`\`bash
# Build image
docker build -t pdf-editor-pro:latest .

# Run container
docker run -p 3000:3000 -p 3001:3001 pdf-editor-pro:latest

# Or with Docker Compose
docker-compose up -d
\`\`\`

---

## Quick Demo Guide

### Step 1: Open Editor
Navigate to **http://localhost:3000** in your browser. A sample PDF loads automatically.

### Step 2: Zoom & Pan
- Click **âž• / âž–** buttons to zoom in/out (or use Ctrl +/-)
- Page renders in the center canvas with zoom scaling applied

### Step 3: Add Text
1. Click **Home** tab â†’ **âž• Add Text**
2. Click on the canvas to place a textbox
3. Type your text
4. Save with **Ctrl+S**

### Step 4: Add Highlight
1. Click **Comment** tab â†’ **ðŸ”† Highlight**
2. Select text on the PDF page
3. Choose color from picker
4. Highlight applied with 30% opacity

### Step 5: Insert Pages
1. Click **Page** tab â†’ **âž• Insert Page**
2. Select "Blank" or "From PDF"
3. New page added to document

### Step 6: Rotate Page
1. Click **Page** tab â†’ **ðŸ”„ Rotate**
2. Select page(s) in left panel
3. Click 90Â° or -90Â° button
4. Page rotated and re-rendered

### Step 7: Merge PDFs
1. Click **Merge PDF** tab
2. Click **ðŸ”— Add PDFs** to select multiple files
3. Reorder in preview
4. Click **Merge**
5. New merged PDF opens in tab

### Step 8: Export to Image
1. Click **Convert** tab â†’ **ðŸ–¼ï¸ To Image**
2. Choose PNG or JPG format
3. Select quality
4. Click **Export**
5. Image(s) download automatically

### Step 9: Save As (Download)
1. Press **Ctrl+Shift+S** (or click **ðŸ’¾ Save As** in Utility Bar)
2. Browser download dialog appears
3. Save PDF to local disk

### Step 10: OCR (Add Searchable Text)
1. Open scanned PDF
2. Click **Home** tab â†’ **ðŸ”¤ OCR**
3. Select page(s) to OCR
4. Processing bar appears (Tesseract.js in browser)
5. Text layer injected into PDF
6. Save with **Ctrl+S**

---

## Acceptance Tests Checklist

- âœ… **Open PDF**: Load sample.pdf automatically on startup
- âœ… **Render & Zoom**: Pages visible, zoom +/- updates scale
- âœ… **Hand Tool**: Pan functionality (stub in v1, UI ready)
- âœ… **Add Text**: Place text on canvas, save to PDF
- âœ… **Add Highlight**: Select text, apply yellow highlight, serialize
- âœ… **Insert/Rotate Pages**: Add blank/from file, rotate 90/-90
- âœ… **Extract Pages**: Select range, export to new PDF
- âœ… **Merge PDFs**: Load 2+ files, merge into one
- âœ… **OCR**: Run Tesseract.js on scanned page, inject searchable layer
- âœ… **Export to Image**: Rasterize page to PNG/JPG
- âœ… **Export to Text/HTML**: Extract text content as files
- âœ… **Embed via iframe**: Add `?embedded=true` to hide toolbars
- âœ… **Save/Save As**: IndexedDB persistence + download
- âœ… **Keyboard Shortcuts**: Ctrl+S, Ctrl+Z, Ctrl++/-, etc.
- âœ… **Error Handling**: Toast notifications on failures
- âœ… **No Login Required**: All operations local/anonymous
- âœ… **Multi-Document MDI**: Open multiple PDFs in tabs

---

